#obtaining the csv
start <- as.Date("2000-02-01")
end <- as.Date("2025-12-31")
getSymbols("^FVX", src = "yahoo", from = start, to = end)
head(FVX)
df <- data.frame(Date = index(FVX), coredata(FVX))
df$Date <- as.Date(df$Date)
df <- na.omit(df)
write.csv(df, "FVX_full.csv", row.names = FALSE)
FVX_csv <- read.csv("FVX_full.csv", stringsAsFactors = FALSE)
prices <- FVX_csv[, "FVX.Adjusted"]
prices <- as.numeric(prices)
head(FVX_csv)
#b
dates_real <- as.Date(FVX_csv$Date)
plot(dates_real,
prices,
type = "l",
main = "5-Year Treasury Yield (Level)",
xlab = "Date",
ylab = "Yield (%)",
col = "purple")
log_returns <- diff(log(prices))
dates_returns <- dates_real[-1] #since r at 1 is not available
plot(dates_returns,
log_returns,
type = "l",
main = "Daily Log-Returns",
xlab = "Date",
col = "turquoise",
ylab = "Log-Return")
acf(log_returns,
ylim = c(-0.1, 0.1),
main = "ACF of Log-Returns")
#c
T <- length(log_returns)
train  <- log_returns[1:(T-20)]
test <- log_returns[(T-19):T]
#ols
y  <- train[3:length(train)]
x1 <- train[2:(length(train)-1)]
x2 <- train[1:(length(train)-2)]
X <- cbind(1, x1, x2)
beta_ols <- solve(t(X) %*% X) %*% t(X) %*% y
mu_ols     <- beta_ols[1]
phi1_ols   <- beta_ols[2]
phi2_ols   <- beta_ols[3]
residuals_ols <- y - X %*% beta_ols
sigma2_ols <- mean(residuals_ols^2)
loglik_ar2 <- function(params, r_data) {
mu    <- params[1]
phi1  <- params[2]
phi2  <- params[3]
log_sigma2 <- params[4]
sigma2 <- exp(log_sigma2)
T <- length(r_data)
eps <- rep(0, T)
for (t in 3:T) {
eps[t] <- r_data[t] -
(mu + phi1*r_data[t-1] + phi2*r_data[t-2])
}
loglik <- - (T/2)*log(2*pi*sigma2) -
sum(eps^2)/(2*sigma2)
return(-loglik)   # negative as optim minimises objectives
}
init_params <- c(mu_ols, phi1_ols, phi2_ols,log(var(train)))
mle_results <- optim(init_params,loglik_ar2,r_data = train, method = "BFGS")
params_mle <- mle_results$par
mu_mle    <- params_mle[1]
phi1_mle  <- params_mle[2]
phi2_mle  <- params_mle[3]
sigma2_mle <- exp(params_mle[4])
#d
ar2_fit <- arima(train, order = c(2,0,0), include.mean = TRUE)
summary(ar2_fit)
mu_arima   <- ar2_fit$coef["intercept"]
phi1_arima <- ar2_fit$coef["ar1"]
phi2_arima <- ar2_fit$coef["ar2"]
sigma2_arima <- ar2_fit$sigma2
comparison <- rbind(
OLS   = c(mu_ols, phi1_ols, phi2_ols),
MLE   = c(mu_mle, phi1_mle, phi2_mle),
ARIMA = c(mu_arima, phi1_arima, phi2_arima)
)
colnames(comparison) <- c("mu", "phi1", "phi2")
comparison
Tt <- length(train)
fitted_vals <- rep(NA, Tt)
for (t in 3:Tt) {
fitted_vals[t] <- mu_arima +
phi1_arima * train[t-1] +
phi2_arima * train[t-2]
}
plot(train, type = "l",
col = "black",
lwd = 1.5,
main = "Actual vs Fitted Log-Returns",
ylab = "Log-Return")
lines(fitted_vals, col = "red", lwd = 1.5)
legend("topright",
legend = c("Actual", "Fitted"),
col = c("black", "red"),
lty = 1,
lwd = 1.5)
#e
residuals_ar2 <- residuals(ar2_fit)
residuals_ar2 <- residuals_ar2[!is.na(residuals_ar2)]
hist(residuals_ar2,
breaks = 40,
probability = TRUE,
main = "Histogram of AR(2) Residuals",
xlab = "Residuals")
curve(dnorm(x,
mean = mean(residuals_ar2),
sd = sd(residuals_ar2)),
col = "red",
lwd = 2,
add = TRUE)
qqnorm(residuals_ar2,       main = "Q-Q Plot of AR(2) Residuals")
qqline(residuals_ar2,       col = "red",       lwd = 2)
#e
h <- 20
forecast_vals <- numeric(h)
r_tm1 <- test[length(test)]
r_tm2 <- test[length(test)-1]
for(i in 1:h){
forecast_vals[i] <- mu_arima + phi1_arima*r_tm1 + phi2_arima*r_tm2
r_tm2 <- r_tm1
r_tm1 <- forecast_vals[i]
}
time_index <- 1:h
plot(time_index, test,
type = "l",
lwd = 2,
col = "black",
xlab = "Forecast Horizon",
ylab = "Log-Returns",
main = "Forecast vs Actual Returns")
lines(time_index, forecast_vals,
col = "red",
lwd = 2)
legend("topright",
legend = c("Actual", "Forecast"),
col = c("black", "red"),
lwd = 2)
comparison
View(comparison)
comparison
sigma2_mle
sigma2_mle
sigma2_mle
sigma2_mle
sigma2_ols
sigma2_ols
sigma_ols
View(comparison)
sigma2_arima
sigma2_arima
install.packages("remotes")
remotes::install_github('jaburgoyne/compmus')
library(tidyverse)
library(compmus)
